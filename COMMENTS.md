# Комментарии к изменениям
Описание изменений и объяснение принятых решений.

## TL;DR
- Доменная модель календаря отделена от DTO; генерация осуществляется с помощью Java Time API с помощью статической фабрики.
- Маппинг реализован через MapStruct; сервис теперь выполняет только кэширование и получение данных.
- Redis добавлен для кэширования и демонстрации интеграции с внешним in-memory хранилищем.
- В проект добавлен Swagger UI.
- Осознанно не введено постоянное хранение самого календаря в реляционной БД (см. комментарий ниже).

## Ключевые изменения в архитектуре
- **Разделение доменной и транспортной модели календаря**:

    - Введена доменная модель календаря. Контракт и реализация разделены на интерфейс (`YearCalendar`) и класс (`GregorianYearCalendar`) соответственно.
    - Реализация по-максимуму использует возможности Java Time API для генерации временных данных.
    - Реализация отдает лениво-инициализируемые стримы данных, поскольку это решение комплементарно Java Time API и соответствует сценарию использования в приложении. 
    - Реализована статическая фабрика (`YearCalendarFactory`) для создания экземпляров календаря.

- **Изменения в DTO и маппинг**:
    - DTO календаря сведён к одному типу (`CalendarDto`) с вложенными записями для месяцев и дней.
    - Добавлен маппер на базе MapStruct (`CalendarMapper`) для преобразования между доменной моделью и DTO.

## Кэширование и Redis
Redis добавлен для демонстрации взаимодействия с сетевой БД, устранения повторной генерации детерминированных данных и маппинга DTO в рамках окна времени, определенного параметрами окружения.
- Кэш Caffeine заменен на сетевую БД Redis.
- Кэширование по-прежнему выполняется с помощью Spring Cache.
- Файл окружения `.env` теперь является обязательным для запуска приложения в Docker.

> [!NOTE]
> **Почему не храню календарь в реляционной БД?**<br/>
> - Календарь за любой год является детерминированной и статической структурой. Он однозначно вычисляем, поэтому его сохранение в БД — дублирование и усложнение жизненного цикла данных (который, по большому счету, отсутствует).
> - Календарь является сложной иерархической структурой. Его хранение в реляционной БД приведёт к реализации одной из схем:
>   - Хранение в виде набора связанных таблиц, соответствующего схеме DTO.
>   - Хранение некоторых собственных полей и большого списка дат в виде TIMESTAMP.
> 
>   Все они приведут к оверхеду в виде хранения избыточных данных, усложнению запросов и потенциальному общему ухудшению производительности в конечном счете. В связи с этим, я отказался от идеи хранения календаря в реляционной БД, посчитав решение избыточным и неудачным.



